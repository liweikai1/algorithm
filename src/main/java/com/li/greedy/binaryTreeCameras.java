package com.li.greedy;

import com.li.binaryTree.HeroNode1;

/**
 * @Author: li wei kai
 * @Date: 2022/05/22/14:31
 * @Description:
 */
public class binaryTreeCameras {
    //贪心策略:二叉树从下往上看，局部最优：让叶⼦节点的⽗节点安摄像头，所⽤摄像头最少，
    // 整体最优：全部摄像头数量所⽤最少！
    public static void main(String[] args) {

    }
    //1.确定遍历顺序；采用后序遍历，
    //2.如何隔两个节点放⼀个摄像头:
    //  此时需要状态转移的公式，和动态的状态转移公式不一样，本题状态转移没有择优的过程，
    //  就是单纯的状态转移！
    //  每个节点有如下三种种状态：1)该节点⽆覆盖,2)本节点有摄像头,3)本节点有覆盖
    //  分别有三个数字来表示：0：该节点⽆覆盖. 1：本节点有摄像头. 2：本节点有覆盖
    // 在遍历树的过程中，会遇到空节点，那么空节点是哪⼀种状态呢？
    //  回归本质，为了让摄像头数量最少，我们要尽量让叶⼦节点的⽗节点安装摄像头，这样才能摄像
    //  头的数量最少。那么空节点不能是⽆覆盖的状态，这样叶⼦节点就要放摄像头了，空节点也不能
    //  是有摄像头的状态，这样叶⼦节点的⽗节点就没有必要放摄像头了，⽽是可以把摄像头放在叶⼦
    //  节点的爷爷节点上。所以空节点的状态只能是有覆盖，这样就可以在叶⼦节点的⽗节点放摄像头了
    // 那么递归的终⽌条件应该是遇到了空节点，此时应该返回2（有覆盖），
    // 递归的函数，以及终⽌条件已经确定了，再来看单层逻辑处理。
    // 主要有如下四类情况：
    //  情况1:左右节点都有覆盖: 左孩⼦有覆盖，右孩⼦有覆盖，那么此时中间节点应该就是⽆覆盖的状态了。
    //  情况2:左右节点⾄少有⼀个⽆覆盖的情况: 则中间节点（⽗节点）应该放摄像头：
    //  情况3:左右节点⾄少有⼀个有摄像头: 其⽗节点就应该是2（覆盖的状态）
    //  情况4:头结点没有覆盖: 递归结束之后，可能头结点 还有⼀个⽆覆盖的情况,
    //       所以递归结束之后，还要判断根节点，
    public static int minCameraCover(HeroNode1 root) {

        return 0 ;
    }
}
