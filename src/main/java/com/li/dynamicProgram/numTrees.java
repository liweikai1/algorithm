package com.li.dynamicProgram;

import java.util.Arrays;

/**
 * @Author: li wei kai
 * @Date: 2022/05/02/22:10
 * @Description:leetcode T96 题目：不同的二叉搜索树
 题目描述：
给你一个整数 n ，求恰由n个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
示例 1：
    输入：n = 3
    输出：5
示例 2：
    输入：n = 1
    输出：1
 */
public class numTrees {
    public static void main(String[] args) {
        int n = 5 ;
        int numTrees = numTrees(n);
        System.out.println(numTrees);
    }
    //动态规划思路：01背包问题
    //给定一个有序序列 1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 i，将该数字作为树根，将 1⋯(i−1) 序列作
    //为左子树，将 (i+1)⋯n 序列作为右子树。接着我们可以按照同样的方式递归构建左子树和右子树。
    //在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。
    //由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。因此，我们可以想到使用动态规划来求解本题。
    //1. 确定dp数组以及下标的含义：dp[i]，1 到 i 为节点组成的⼆叉搜索树的个数为 dp[i]。
    //2. 确定递推公式：给定序列 1⋯n，我们选择数字 i 作为根，则根为 i 的所有二叉搜索树的集合是左子树集合和右子树
    //   集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，
    //   dp[i] += dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量]
    //   j相当于是头结点的元素，从1遍历到i为⽌。
    //   所以递推公式：dp[i] += dp[j - 1] * dp[i - j];
    //   j-1 为j为头结点左⼦树节点数量，i-j 为以j为头结点右⼦树节点数量
    //3. dp数组如何初始化：初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。
    //   从定义上来讲，空节点也是⼀颗⼆叉树，也是⼀颗⼆叉搜索树，这是可以说得通的。
    //   从递归公式上来讲，dp[以j为头结点左⼦树节点数量] * dp[以j为头结点右⼦树节点数量] 中以j为头结点左⼦树节点
    //   数量为0，也需要dp[以j为头结点左⼦树节点数量] = 1， 否则乘法的结果就都变成0了。所以初始化dp[0] = 1 。
    //4. 确定遍历顺序：⾸先⼀定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，
    //   节点数为i的状态是依靠 i之前节点数的状态。那么遍历i⾥⾯每⼀个数作为头结点的状态，⽤j来遍历。
    //5. 举例推导dp数组
    public static int numTrees(int n) {
        int[] dp = new int[n+1] ;
        dp[0] = 1 ;
        dp[1] = 1 ;
        for(int i = 2 ; i <= n ; i++){
            for(int j = 1 ; j <= i ; j++){
                dp[i] += dp[j-1] * dp[i-j] ;
            }
        }
        System.out.println(Arrays.toString(dp));
        return dp[n] ;
    }
}
